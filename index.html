<!DOCTYPE html>
<html lang="ms">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chill Bubble Pop</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; }
    canvas { touch-action: none; }
    .soft-shadow { box-shadow: 0 20px 50px rgba(2,132,199,.15), 0 8px 20px rgba(15,23,42,.1); }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-b from-sky-50 to-white text-slate-800 antialiased">
  <main class="mx-auto max-w-3xl px-4 py-8">
    <div class="rounded-2xl bg-white border border-slate-100 p-4 md:p-6 soft-shadow">
      <header class="flex flex-wrap items-center gap-3 justify-between">
        <h1 class="text-xl md:text-2xl font-semibold">ðŸ«§ Chill Bubble Pop</h1>
        <div class="flex items-center gap-2">
          <span class="text-sm text-slate-500">Mode:</span>
          <select id="mode" class="rounded-lg border border-slate-300 px-3 py-1.5 text-sm">
            <option value="zen">Zen (âˆž)</option>
            <option value="burst">30s Burst</option>
          </select>
          <button id="startBtn" class="px-4 py-2 rounded-xl bg-sky-600 text-white text-sm hover:bg-sky-700">Start</button>
          <button id="resetBtn" class="px-4 py-2 rounded-xl border border-slate-300 text-sm hover:bg-slate-50">Reset</button>
        </div>
      </header>

      <section class="mt-4 grid md:grid-cols-[1fr_auto] gap-4">
        <div class="relative rounded-xl overflow-hidden border border-slate-200">
          <canvas id="game" class="w-full h-[56vh] md:h-[60vh] block bg-gradient-to-b from-white to-sky-50"></canvas>
          <div id="tapHint" class="pointer-events-none absolute inset-x-0 bottom-3 text-center text-xs text-slate-500">
            Tap/click untuk pecahkan buih â€¢ Seret jari untuk combo
          </div>
        </div>
        <aside class="grid gap-3 content-start">
          <div class="rounded-xl border border-slate-200 p-3">
            <div class="text-xs text-slate-500">Skor</div>
            <div id="score" class="text-3xl font-semibold">0</div>
          </div>
          <div class="rounded-xl border border-slate-200 p-3">
            <div class="text-xs text-slate-500">Masa</div>
            <div id="timer" class="text-3xl font-semibold">âˆž</div>
          </div>
          <div class="rounded-xl border border-slate-200 p-3">
            <div class="text-xs text-slate-500">Combo</div>
            <div id="combo" class="text-3xl font-semibold">x1</div>
          </div>
          <div class="text-xs text-slate-500">
            Tip: Pecahkan beberapa buih cepat-cepat untuk tingkatkan combo.
          </div>
        </aside>
      </section>
    </div>
  </main>

  <script>
    // ===== Setup canvas =====
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: true });
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    function resize() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
    }
    resize();
    window.addEventListener('resize', resize);

    // ===== Game state =====
    const modeSel = document.getElementById('mode');
    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');
    const scoreEl = document.getElementById('score');
    const timerEl = document.getElementById('timer');
    const comboEl = document.getElementById('combo');
    const tapHint = document.getElementById('tapHint');

    let bubbles = [];
    let particles = [];
    let running = false;
    let lastSpawn = 0;
    let score = 0;
    let combo = 1;
    let comboTimer = 0;
    let timeLeft = Infinity; // seconds
    let lastTime = performance.now();

    // ===== Helpers =====
    const rand = (min, max) => Math.random() * (max - min) + min;
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    function spawnBubble() {
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const r = rand(14, 36); // radius in css px
      const x = rand(r, w - r);
      const y = h + r + rand(0, 40); // spawn below
      const speed = rand(20, 60); // px per sec upward
      const hue = rand(180, 220); // calm blue range
      bubbles.push({
        x, y, r, vy: -speed, vx: rand(-10, 10),
        wobbleA: rand(0.8, 1.4), wobbleT: rand(0, Math.PI * 2),
        hue, alpha: 0.85,
      });
    }

    function popBubble(i, strong=false) {
      const b = bubbles[i];
      if (!b) return;
      // particles
      const n = strong ? 32 : 18;
      for (let k = 0; k < n; k++) {
        const a = rand(0, Math.PI * 2);
        const sp = strong ? rand(90, 180) : rand(70, 130);
        particles.push({
          x: b.x, y: b.y,
          vx: Math.cos(a) * sp,
          vy: Math.sin(a) * sp,
          life: rand(0.35, 0.75),
          size: rand(1.5, 3.5),
          hue: b.hue + rand(-10, 10),
          alpha: 1
        });
      }
      // score + combo
      score += 1 * combo;
      scoreEl.textContent = score;
      combo = clamp(combo + 0.1, 1, 5);
      comboEl.textContent = 'x' + combo.toFixed(1);
      comboTimer = 1.2; // seconds to keep combo
      // haptics
      if (navigator.vibrate) navigator.vibrate(6);
      // remove bubble
      bubbles.splice(i, 1);
    }

    // ===== Input (click/touch/drag) =====
    function pointerPos(e) {
      const rect = canvas.getBoundingClientRect();
      if (e.touches && e.touches[0]) {
        return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
      }
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }
    function handlePop(e) {
      if (!running) return;
      const p = pointerPos(e);
      // allow "drag to pop": check all bubbles within finger path radius
      const radius = 28;
      let popped = false;
      for (let i = bubbles.length - 1; i >= 0; i--) {
        const b = bubbles[i];
        const dx = b.x - p.x, dy = b.y - p.y;
        if (dx*dx + dy*dy <= (b.r + radius) * (b.r + radius)) {
          popBubble(i);
          popped = true;
        }
      }
      if (!popped) {
        // gentle ripple if missed
        particles.push({ x: p.x, y: p.y, vx: 0, vy: 0, life: 0.25, size: 8, hue: 210, alpha: .25 });
        combo = 1; comboEl.textContent = 'x1';
      }
      e.preventDefault();
    }
    canvas.addEventListener('mousedown', handlePop);
    canvas.addEventListener('mousemove', (e) => { if (e.buttons === 1) handlePop(e); });
    canvas.addEventListener('touchstart', handlePop, { passive: false });
    canvas.addEventListener('touchmove', handlePop, { passive: false });

    // ===== Loop =====
    function update(dt) {
      // spawn rate depends on mode
      const spawnEvery = modeSel.value === 'zen' ? 0.25 : 0.18; // seconds
      lastSpawn += dt;
      while (lastSpawn > spawnEvery) {
        spawnBubble();
        lastSpawn -= spawnEvery;
      }
      // move bubbles
      for (let i = bubbles.length - 1; i >= 0; i--) {
        const b = bubbles[i];
        b.wobbleT += dt * b.wobbleA;
        b.x += Math.cos(b.wobbleT) * 12 * dt + b.vx * dt * 0.1;
        b.y += b.vy * dt;
        if (b.y < -b.r - 20) bubbles.splice(i, 1);
      }
      // particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dt;
        p.x += p.vx * dt * 0.5;
        p.y += p.vy * dt * 0.5;
        p.vy += 40 * dt * 0.5; // soft gravity
        p.alpha = Math.max(0, p.life * 1.5);
        if (p.life <= 0) particles.splice(i, 1);
      }
      // combo decay
      if (combo > 1) {
        comboTimer -= dt;
        if (comboTimer <= 0) { combo = 1; comboEl.textContent = 'x1'; }
      }
      // timer
      if (modeSel.value === 'burst' && running) {
        timeLeft -= dt;
        timerEl.textContent = Math.max(0, Math.ceil(timeLeft));
        if (timeLeft <= 0) {
          running = false;
          timerEl.textContent = '0';
          // small finale burst
          for (let i = 0; i < 60; i++) {
            particles.push({
              x: rand(20, canvas.clientWidth - 20),
              y: rand(20, canvas.clientHeight - 20),
              vx: rand(-140, 140),
              vy: rand(-140, 140),
              life: rand(0.4, 0.9),
              size: rand(1.5, 3),
              hue: rand(180, 220),
              alpha: 1
            });
          }
        }
      } else {
        timerEl.textContent = 'âˆž';
      }
    }

    function draw() {
      // clear with super-soft gradient wash
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ctx.clearRect(0, 0, w, h);

      // subtle background bubbles
      for (let i = 0; i < 6; i++) {
        const rx = ((i * 97) % w);
        const ry = ((i * 53) % h);
        const rr = 60 + (i * 10);
        const g = ctx.createRadialGradient(rx, ry, 0, rx, ry, rr);
        g.addColorStop(0, 'rgba(14,165,233,0.06)');
        g.addColorStop(1, 'rgba(14,165,233,0.0)');
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(rx, ry, rr, 0, Math.PI * 2); ctx.fill();
      }

      // bubbles
      for (const b of bubbles) {
        const g = ctx.createRadialGradient(b.x - b.r*0.4, b.y - b.r*0.4, b.r*0.1, b.x, b.y, b.r);
        g.addColorStop(0, `hsla(${b.hue}, 80%, 70%, ${b.alpha})`);
        g.addColorStop(1, `hsla(${b.hue}, 90%, 55%, ${b.alpha * 0.8})`);
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); ctx.fill();

        // gloss
        ctx.strokeStyle = `hsla(${b.hue}, 100%, 98%, ${0.8})`;
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(b.x - b.r*0.3, b.y - b.r*0.3, b.r*0.25, 0, Math.PI * 2); ctx.stroke();
      }

      // particles
      for (const p of particles) {
        ctx.fillStyle = `hsla(${p.hue}, 90%, 60%, ${p.alpha})`;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
      }
    }

    function loop(t) {
      const now = t || performance.now();
      const dt = Math.min(0.05, (now - lastTime) / 1000); // clamp dt
      lastTime = now;

      if (running) update(dt);
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // ===== Controls =====
    function startGame() {
      running = true;
      tapHint.style.opacity = 0.0;
      bubbles.length = 0;
      particles.length = 0;
      score = 0; combo = 1; comboTimer = 0;
      scoreEl.textContent = '0'; comboEl.textContent = 'x1';
      if (modeSel.value === 'burst') {
        timeLeft = 30; timerEl.textContent = '30';
      } else {
        timeLeft = Infinity; timerEl.textContent = 'âˆž';
      }
    }
    function resetGame() {
      running = false;
      tapHint.style.opacity = 1.0;
      bubbles.length = 0;
      particles.length = 0;
      score = 0; combo = 1; comboTimer = 0; timeLeft = Infinity;
      scoreEl.textContent = '0'; timerEl.textContent = 'âˆž'; comboEl.textContent = 'x1';
    }

    startBtn.addEventListener('click', startGame);
    resetBtn.addEventListener('click', resetGame);
  </script>
</body>
</html>
